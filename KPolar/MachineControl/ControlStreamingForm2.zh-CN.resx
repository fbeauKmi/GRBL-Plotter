<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="groupBox1.ToolTip" xml:space="preserve">
    <value>立即更改馈送覆盖值。主动进给动作会在几十毫秒内改变。
不会改变快速速率，包括G0、G28和G30，或慢跑运动。
进料超控值不能为10%或大于200%。
如果馈送覆盖值不变，则忽略该命令。
饲料覆盖范围和增量可以在config.h中更改。</value>
  </data>
  <data name="groupBox2.ToolTip" xml:space="preserve">
    <value>立即更改主轴速度超控值。主动主轴速度在几十毫秒内改变。
无论主轴是启用还是禁用，超控值都可以随时更改。
主轴超控值不能为10%或大于200%
如果主轴超控值没有改变，则忽略该命令。
主轴超控范围和增量可以在config.h中更改。</value>
  </data>
  <data name="btnToggleSS.ToolTip" xml:space="preserve">
    <value>立即切换主轴启用或禁用状态，但仅限于处于保持状态时。
否则，该命令将被忽略，尤其是在运动时。这可以防止在作业过程中意外禁用，否则可能会损坏零件/机器或造成人身伤害。工业机器处理主轴停止超控的方式类似。
当通过循环启动重新开始运动时，将恢复最后一个主轴状态，并在恢复刀具路径之前等待4.0秒（可配置）。这可以确保用户不会忘记重新打开它。
禁用时，主轴速度超控值仍可更改，一旦重新启用主轴，该值将生效。
如果安全门打开，door状态将取代主轴停止超控，在关闭门并恢复时，它将管理主轴重新通电。清除并重置之前的主轴停止超控状态。</value>
  </data>
  <data name="btnToggleMC.ToolTip" xml:space="preserve">
    <value>通过ENABLE_M7编译时选项启用。默认设置已禁用。
切换雾状冷却液状态和输出引脚，直到下一个切换或g-代码命令改变它。
在空闲、运行或保持状态下，可以随时发出命令。否则，它将被忽略。
此覆盖直接更改了g-代码解析器中的冷却剂模式状态。Grbl将继续正常运行，就像它接收并执行M7或M9 g代码命令一样。
当查询$G G-代码解析器状态时，切换覆盖更改将通过启用或禁用M7来反映，M9或M8存在时不出现。</value>
  </data>
  <data name="btnToggleFC.ToolTip" xml:space="preserve">
    <value>切换溢流冷却液状态和输出引脚，直到下一个切换或g-代码命令改变它。
在空闲、运行或保持状态下，可以随时发出命令。否则，它将被忽略。
此覆盖直接更改了g-代码解析器中的冷却剂模式状态。Grbl将继续正常运行，就像它收到并执行M8或M9 g代码命令一样。
当查询$G G-代码解析器状态时，切换覆盖更改将通过启用或禁用M8以及M9或在M7存在时不出现来反映。</value>
  </data>
  <data name="btnOverrideSD.ToolTip" xml:space="preserve">
    <value>虽然通常连接到输入引脚以检测安全门的打开，但此命令允许GUI使用此命令执行安全门行为。
立即暂停到DOOR状态并禁用主轴和冷却液。如果在运动中，机器将减速停止，然后暂停。
如果在归航过程中执行，Grbl将停止运动并发出归航警报。
如果已经处于挂起状态或保持状态，则DOOR状态将取代它。
如果启用了驻车编译时间选项，Grbl将把主轴驻车到指定位置。
当Grbl处于空闲、保持、运行、归位或点动状态时，命令执行。否则，它将被忽略。
如果慢跑，安全门将取消慢跑和计划缓冲区中所有排队的动作。当安全门关闭并恢复时，Grbl将返回空闲状态。
如果启用了编译时选项，则可以使用输入引脚连接按钮或开关。</value>
  </data>
</root>